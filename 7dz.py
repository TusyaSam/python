# Задача 34:  Винни-Пух попросил Вас посмотреть, есть ли в его стихах ритм. 
# Поскольку разобраться в его кричалках не настолько просто, насколько 
# легко он их придумывает, Вам стоит написать программу. Винни-Пух считает,
# что ритм есть, если число слогов (т.е. число гласных букв) в каждой фразе 
# стихотворения одинаковое. Фраза может состоять из одного слова, если во фразе 
# несколько слов, то они разделяются дефисами. Фразы отделяются друг от друга пробелами.
# Стихотворение  Винни-Пух вбивает в программу с клавиатуры. В ответе напишите 
# “Парам пам-пам”, если с ритмом все в порядке и “Пам парам”, если с ритмом все не в порядке

# *Пример:*

# **Ввод:** пара-ра-рам рам-пам-папам па-ра-па-да    
#     **Вывод:** Парам пам-пам  

# song = input().lower()
# volwes = ['а','е','о','и','ё','я','ы','ю','э','у']
# parts = song.split()
# itog = list()  # или itog = list(map(lambda x: sum(1 for i in x if i in 'уеэоаыяиюё'), parts)) и проверяем if len(set(itog)) == 1: print('Парам пам-пам')
# for i in parts:
#     k=0
#     for letter in i:
#         if letter in volwes:
#             k += 1
#     itog.append(k)
# if len(set(itog)) == 1:
#     print ('Парам пам-пам')
# else:
#     print ('Пам-парам')



# Задача 36: На вход программы поступает строка в формате:
# ключ_1=значение_1 ключ_2=значение_2 ... ключ_N=значение_N
# Необходимо с помощью функции map преобразовать ее в кортеж tp вида:
# tp = (('ключ_1', 'значение_1'), ('ключ_2', 'значение_2'), ..., ('ключ_N', 'значение_N'))
# Выводить на экран получившийся кортеж.
# Sample Input:
# house=дом car=машина men=человек tree=дерево
# Sample Output:
# ((house, дом), (car, машина), (men, человек), (tree, дерево))

list = input().split()
res = tuple(map(lambda x: tuple(x.split('=')), list))
print(res)







# Напишите функцию same_by(characteristic, objects), которая проверяет,
# все ли объекты имеют одинаковое значение некоторой характеристики,
# и возвращают True, если это так. Если значение характеристики для 
# разных объектов отличается - то False. Для пустого набора объектов, 
# функция должна возвращать True. Аргумент characteristic - это функция,
# которая принимает объект и вычисляет его характеристику.

def char(x):
    return x % 2


def same_by(characteristic, objects):
    objects = set(map(characteristic, objects))
    if len(objects) == 1:
        return True
    return False
        
# mass = [1, 1, 1, 1]
# print(same_by(char, mass))

# У вас есть код, который вы не можете менять
# (так часто бывает, когда код в глубине программы
#   используется множество раз и вы не хотите ничего сломать):
# transformation = <???>
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # или любой другой список
# transormed_values = list(map(transformation, values))
# Единственный способ вашего взаимодействия с этим кодом - 
# посредством задания функции transformation.
# Однако вы поняли, что для вашей текущей задачи вам не
# нужно никак преобразовывать список значений, а нужно получить его как есть.
# Напишите такое лямбда-выражение transformation, чтобы
# transformed_values получился копией values.

# transformation = lambda x : x
    
# values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
# transormed_values = list(map(transformation, values))
# print(transormed_values)

# Планеты вращаются вокруг звезд по эллиптическим орбитам. 
# Назовем самой далекой планетой ту, орбита которой имеет
# самую большую площадь. Напишите функцию find_farthest_orbit(list_of_orbits),
# которая среди списка орбит планет найдет ту, по которой вращается
# самая далекая планета. Круговые орбиты не учитывайте: вы знаете,
# что у вашей звезды таких планет нет, зато искусственные спутники
# были были запущены на круговые орбиты. Результатом функции должен
# быть кортеж, содержащий длины полуосей эллипса орбиты самой далекой планеты. 
# Каждая орбита представляет из себя кортеж из пары чисел - полуосей ее эллипса. 
# Площадь эллипса вычисляется по формуле S = pi*a*b, где a и b - длины полуосей эллипса.
# При решении задачи используйте списочные выражения. Подсказка: проще всего будет 
# найти эллипс в два шага: сначала вычислить самую большую площадь эллипса, 
# а затем найти и сам эллипс, имеющий такую площадь. Гарантируется, 
# что самая далекая планета ровно одна

# [(1, 2), (4, 4), (3, 2)] -> (3, 2)

list_of_orbits = [(1, 2), (4, 4), (3, 2)]

def find_farthest_orbit(list_of_orbits):
    list_of_orbits = list(filter(lambda x: x[0] != x[1], list_of_orbits))
    s = []
    for i in list_of_orbits:
        s.append(3.14 * i[0] * i[1])
    res = s.index(max(s))
    return list_of_orbits[res]

# print(find_farthest_orbit(list_of_orbits))


# или


def find_farthest_orbit(lst: list[tuple]):
    return max(lst, key = lambda y: (y[0] != y[1], y[0] * y[1]))
# print(find_farthest_orbit(list_of_orbits))